<!doctype html>

<html lang="en"> <head> <meta charset="utf-8"/> <meta name="viewport" content="width=device-width,initial-scale=1"/> <title>Beast Search — Fixed Enhanced Single File</title> <style> :root{ --bg:#071020; --muted:rgba(255,255,255,0.65); --accent1:#ff2d2d; --accent2:#7c0df5; } html,body{height:100%;margin:0;background:linear-gradient(180deg,#05060a,#0b1120);font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#e9f0ff} .container{display:flex;align-items:center;justify-content:center;padding:28px;min-height:100vh} .card{width:96vw;max-width:1100px;border-radius:14px;padding:18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 12px 40px rgba(2,6,23,0.6);backdrop-filter: blur(8px);border:1px solid rgba(255,255,255,0.03)} .header{display:flex;align-items:center;gap:12px} .logo{width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--accent1),var(--accent2));display:flex;align-items:center;justify-content:center;font-weight:700;color:white} .title{font-size:18px;margin:0} .subtitle{color:var(--muted);font-size:13px;margin-top:4px} .controls{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px} .input{flex:1;display:flex;gap:8px} input[type=text]{flex:1;padding:12px 14px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;font-size:15px;outline:none} .select,button{padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;cursor:pointer} button.primary{background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#fff;border:none;font-weight:700} .small{font-size:13px;color:var(--muted)} .row{display:flex;gap:10px;align-items:center;margin-top:12px} .answer{margin-top:16px;padding:16px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.018), rgba(255,255,255,0.01));min-height:84px;line-height:1.6;font-size:15px;position:relative;overflow:auto} .controls-bottom{display:flex;gap:10px;align-items:center;margin-top:12px;flex-wrap:wrap} .proxy-list{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px} .proxy-pill{padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02);font-size:12px} .snippet{padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);margin-top:8px} .highlight{background: linear-gradient(90deg, rgba(255,210,90,0.14), rgba(255,210,90,0.06)); padding:2px 4px;border-radius:4px} .entity{background: linear-gradient(90deg, rgba(124,13,245,0.12), rgba(124,13,245,0.06)); padding:2px 4px;border-radius:4px} .provenance{margin-top:12px;border-radius:10px;padding:12px;background:rgba(255,255,255,0.018);font-size:14px} .code-block{background:#00111a;padding:12px;border-radius:8px;color:#cfeff8;white-space:pre;overflow:auto;font-family:monospace;font-size:13px} .runjs{padding:6px 8px;border-radius:8px;background:rgba(0,0,0,0.25);color:#fff;border:none} .download{padding:8px 10px;border-radius:8px;background:linear-gradient(90deg,var(--accent2),var(--accent1));color:white;border:none} .toggle{cursor:pointer;color:var(--muted);text-decoration:underline} .footer{margin-top:12px;color:var(--muted);font-size:12px} </style> <!-- Tesseract.js for OCR --> <script src="https://unpkg.com/tesseract.js@4.0.2/dist/tesseract.min.js"></script> </head> <body> <div class="container"> <div class="card" role="main" aria-live="polite"> <div class="header"> <div class="logo">B</div> <div> <div class="title">Beast Search — Fixed</div> <div class="subtitle">Improved stability, consistent responses & better error handling (no external paid APIs)</div> </div> </div> <div class="controls"> <div class="input"> <input id="q" type="text" placeholder="Ask anything (e.g. 'Photosynthesis' or 'write a quick python function that reverses a list')"> </div> <select id="engine" class="select" title="Search engine"> <option value="duckduckgo">DuckDuckGo (recommended)</option> <option value="bing">Bing</option> </select> <select id="proxyMode" class="select" title="Proxy strategy"> <option value="auto">Proxy pool (recommended)</option> <option value="single">First proxy only</option> </select>
<button id="go" class="primary">Search</button>

</div> <div class="row"> <div class="small">Spelling:</div> <div id="correction" class="small" style="margin-left:6px;color:#ffd8a8"></div> <div style="flex:1"></div> <label style="cursor:pointer" class="small"> <input id="imgfile" type="file" accept="image/*" style="display:none"/>
<span style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);">Upload image (OCR)</span>

</label>
<button id="translateBtn" class="select">Translate</button>

</div> <div id="status" class="small" style="margin-top:8px">Ready.</div> <div id="answer" class="answer">Your concise answer will appear here.</div> <div class="controls-bottom"> <div class="small">Show:</div> <div id="toggleSources" class="toggle small">Sources</div> <div id="toggleSnips" class="toggle small">Raw snippets</div> <div id="toggleCode" class="toggle small">Code view</div> <div class="small" style="margin-left:6px">Confidence: <span id="conf" class="small">—</span></div> <div style="flex:1"></div>
<button id="downloadBtn" class="download">Download Answer</button>

</div> <div id="sources" style="display:none;margin-top:12px"></div> <div id="snippets" style="display:none;margin-top:12px"></div> <div id="codeview" style="display:none;margin-top:12px"></div> <div id="provenance" class="provenance" style="display:none"></div> <div class="proxy-list" id="proxyList" aria-hidden="true"></div> <div class="footer">Tip: this page uses public proxies — reliability varies. For rock-solid results run a tiny local fetcher (I can provide it).</div> </div> </div> <script> /* ------------------------- Beast Search — Fixed single file - Consistent tryFetch return format - Timeout protection for fetches - Defensive HTML parsing - Cleaner helpers and single escapeHtml - Tesseract OCR flow fixed ------------------------- */ const proxies = [ "https://api.allorigins.win/get?url=", "https://api.allorigins.cf/get?url=", "https://api.codetabs.com/v1/proxy?quest=", "https://thingproxy.freeboard.io/fetch/", "https://corsproxy.io/?" ]; const proxyListEl = document.getElementById('proxyList'); function showProxyList(){ proxyListEl.innerHTML=''; proxies.forEach(p=>{const d=document.createElement('div');d.className='proxy-pill';d.textContent=p;proxyListEl.appendChild(d)})} showProxyList(); const qInput = document.getElementById('q'); const goBtn = document.getElementById('go'); const engineEl = document.getElementById('engine'); const proxyModeEl = document.getElementById('proxyMode'); const statusEl = document.getElementById('status'); const answerEl = document.getElementById('answer'); const sourcesEl = document.getElementById('sources'); const snippetsEl = document.getElementById('snippets'); const codeviewEl = document.getElementById('codeview'); const provEl = document.getElementById('provenance'); const confEl = document.getElementById('conf'); const correctionEl = document.getElementById('correction'); const toggleSourcesBtn = document.getElementById('toggleSources'); const toggleSnipsBtn = document.getElementById('toggleSnips'); const toggleCodeBtn = document.getElementById('toggleCode'); const imgfile = document.getElementById('imgfile'); const translateBtn = document.getElementById('translateBtn'); const downloadBtn = document.getElementById('downloadBtn'); const sleep = ms => new Promise(r => setTimeout(r, ms)); /* unified escape */ function escapeHtml(s){ if (s===null || s===undefined) return ''; return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[m])); } /* fetch with timeout */ async function fetchWithTimeout(resource, options = {}) { const { timeout = 9000 } = options; const controller = new AbortController(); const id = setTimeout(() => controller.abort(), timeout); try { const response = await fetch(resource, { ...options, signal: controller.signal }); clearTimeout(id); return response; } catch (err) { clearTimeout(id); throw err; } } /* proxy fetch — normalizes response to return HTML string; returns object { html, usedProxy } */ async function fetchThroughProxy(proxyPrefix, targetUrl, timeout=9000){ // proxyPrefix expected to be prefix that accepts encoded url appended try { let url; if (proxyPrefix.includes('corsproxy.io') && proxyPrefix.endsWith('?')) { url = proxyPrefix + encodeURIComponent(targetUrl); } else { url = proxyPrefix + encodeURIComponent(targetUrl); } const resp = await fetchWithTimeout(url, { mode: 'cors', timeout }); if (!resp.ok) throw new Error('proxy returned ' + resp.status); const text = await resp.text(); // many proxies wrap with JSON; try parse try { const j = JSON.parse(text); if (j.contents) return { html: j.contents, usedProxy: proxyPrefix }; if (j.content) return { html: j.content, usedProxy: proxyPrefix }; if (j.html) return { html: j.html, usedProxy: proxyPrefix }; if (j.data && typeof j.data === 'string') return { html: j.data, usedProxy: proxyPrefix }; } catch (e) { // not JSON — proceed } // raw HTML fallback return { html: text, usedProxy: proxyPrefix }; } catch (err) { throw err; } } /* tryFetch returns { html, usedProxy } or throws */ async function tryFetch(targetUrl, mode='auto'){ if (mode === 'single') { const p = proxies[0]; return await fetchThroughProxy(p, targetUrl).catch(e => { throw e; }); } // auto: iterate proxies for (let i=0;i<proxies.length;i++){ const p = proxies[i]; statusEl.textContent = `Trying proxy ${i+1}/${proxies.length} — ${p}`; try { const r = await fetchThroughProxy(p, targetUrl, 8000); if (r && r.html && r.html.length > 200) return r; } catch (e) { console.warn('proxy failed', p, e && e.message); await sleep(150); continue; } } // final: try direct (may fail due to CORS) statusEl.textContent = 'Trying direct fetch (may be blocked)...'; try { const resp = await fetchWithTimeout(targetUrl, { timeout: 6000 }); const txt = await resp.text(); if (txt && txt.length > 200) return { html: txt, usedProxy: 'direct' }; throw new Error('direct fetch returned insufficient content'); } catch (err) { throw new Error('All proxies + direct fetch failed: ' + (err.message || err)); } } /* Helper - normalize href to absolute if possible */ function normalizeHref(href, baseUrl){ try { return new URL(href, baseUrl).href; } catch (e) { return href; } } /* Extract snippets, links, and code blocks robustly */ function extractSnippetsAndLinksFromHTML(html, engine, baseUrl=''){ try { const doc = new DOMParser().parseFromString(html, 'text/html'); const snippets = []; const links = []; const codes = []; // engine-specific selectors let nodeList = []; if (engine === 'duckduckgo'){ nodeList = Array.from(doc.querySelectorAll('.result__snippet, .result__a, .result__body .result__snippet, .result__title')); } else if (engine === 'bing'){ nodeList = Array.from(doc.querySelectorAll('.b_caption p, .b_algo p, .b_snippet, .b_algo h2 a')); } else { nodeList = Array.from(doc.querySelectorAll('p')); } nodeList.forEach(n => { const t = (n.innerText || n.textContent || '').trim(); if (t && t.length > 30) snippets.push(t.replace(/\s+/g,' ')); // get nearest anchor for link const a = n.closest('a') || n.querySelector('a') || (n.parentElement && n.parentElement.closest && n.parentElement.closest('a')); if (a && a.href) links.push({ href: normalizeHref(a.getAttribute('href') || a.href, baseUrl), text: (a.innerText||a.textContent||'').trim() }); }); // find other anchors Array.from(doc.querySelectorAll('a[href]')).forEach(a=>{ try { const href = a.getAttribute('href') || a.href; if (!href) return; const norm = normalizeHref(href, baseUrl); links.push({ href: norm, text: (a.innerText||a.textContent||norm).trim() }); } catch(e){} }); // code blocks Array.from(doc.querySelectorAll('pre, code')).forEach(c=>{ const t = (c.innerText||c.textContent||'').trim(); if (t && t.length > 20) codes.push(t); }); // dedupe snippets and links const seenS = new Set(); const uniqSnips = snippets.filter(s => { const k = s.toLowerCase().slice(0,160); if (seenS.has(k)) return false; seenS.add(k); return true; }); const seenL = new Set(); const uniqLinks = links.filter(l => { const k = l.href.split('#')[0]; if (seenL.has(k)) return false; seenL.add(k); return true; }); return { snippets: uniqSnips.slice(0,12), links: uniqLinks.slice(0,8), codes: codes.slice(0,8) }; } catch (err) { console.warn('extractSnippets error', err); return { snippets: [], links: [], codes: [] }; } } /* Levenshtein for simple correction */ function levenshtein(a,b){ if(!a) return b.length; if(!b) return a.length; const m = a.length, n=b.length; const dp = Array.from({length:m+1}, (_,i)=>Array(n+1).fill(0)); for(let i=0;i<=m;i++) dp[i][0]=i; for(let j=0;j<=n;j++) dp[0][j]=j; for(let i=1;i<=m;i++){ for(let j=1;j<=n;j++){ const cost = a[i-1]===b[j-1] ? 0 : 1; dp[i][j] = Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost); } } return dp[m][n]; } const commonWords = ["the","be","to","of","and","a","in","that","have","i","it","for","not","on","with","he","as","you","do","at","this","but","his","by","from","they","we","say","her","she","or","an","will","my","one","all","would","there","their"]; /* bestCorrection: returns corrected word or null */ function bestCorrection(word, contextWords){ if (!word || word.length < 2) return null; const candidates = new Set(); contextWords = (contextWords || []).filter(Boolean).slice(0,800); contextWords.forEach(w => { if (w && w.length>1 && w.length<20) candidates.add(w.toLowerCase()); }); commonWords.forEach(w => candidates.add(w)); let best = null, bestScore = Infinity; candidates.forEach(c => { const dist = levenshtein(word.toLowerCase(), c); if (dist < bestScore && dist <= Math.max(2, Math.floor(word.length/2))) { best = c; bestScore = dist; } }); if (best && bestScore <= Math.max(2, Math.floor(word.length/3))) return best; return null; } /* scoring sentences for summarization */ function scoreSentences(snippets, query){ const qwords = (query||'').toLowerCase().split(/\s+/).filter(Boolean); const sentences = []; snippets.forEach(s => { const parts = s.split(/(?<=[.!?])\s+/); parts.forEach(p => { const t = p.replace(/\s+/g,' ').trim(); if (t.length>20) sentences.push(t); }); }); const scored = sentences.map(s => { const low = s.toLowerCase(); let score = 0; qwords.forEach(w => { if (low.includes(w)) score += 4; }); if (/\d/.test(s)) score += 1; score += Math.max(0, 3 - Math.floor(s.length/120)); const caps = (s.match(/\b[A-Z][a-z]{2,}\b/g) || []).length; score += Math.min(3, caps); return { s, score }; }); scored.sort((a,b) => b.score - a.score); const out = []; const seen = new Set(); for (const it of scored) { const key = it.s.toLowerCase().slice(0,160); if (!seen.has(key)){ seen.add(key); out.push(it.s); } if (out.length >= 4) break; } return out; } /* synthesize answer (short) */ function synthesizeAnswer(snippets, links, query){ if (!snippets || snippets.length === 0) return { answer: `I couldn't find clear information on "${query}".`, conf: 'Low', usedSentences: [] }; const qwords = (query||'').toLowerCase().split(/\s+/).filter(Boolean); // short query special-case if (qwords.length <= 2) { for (const s of snippets) { const m = s.match(new RegExp(`\\b${escapeRegExp(query)}\\b\\s+(is|are|refers to|means|was|is called)\\s+([^\\.\\n]+)`, 'i')); if (m && m[2]) { const def = m[2].split(/[,.;:()]/)[0].trim(); return { answer: def, conf: 'High', usedSentences: [s] }; } } } const topSents = scoreSentences(snippets, query); if (topSents.length === 0) { const fallback = snippets[0].split(/[.!?]/)[0].trim(); return { answer: `About ${query}: ${fallback}`, conf: 'Medium', usedSentences: [snippets[0]] }; } let chosen = topSents.slice(0, Math.min(3, topSents.length)); if (qwords.length <= 2 && chosen.length > 0) chosen[0] = chosen[0].split(/[,;:-]/)[0].trim(); const ans = (qwords.length <= 2 && chosen.length === 1 && chosen[0].split(/\s+/).length <= 6) ? chosen[0] : (`About ${query}: ${chosen.join('. ')}.`); // confidence: count overlapping tokens among top snippets const overlap = countTokenOverlap(snippets.slice(0,6)); const conf = overlap >= 3 ? 'High' : overlap >= 1 ? 'Medium' : 'Low'; return { answer: ans, conf, usedSentences: chosen }; } function countTokenOverlap(snips){ const counts = {}; snips.forEach(s => { (s||'').toLowerCase().split(/\W+/).filter(Boolean).forEach(t => counts[t] = (counts[t]||0) + 1); }); let overlap = 0; Object.values(counts).forEach(c => { if (c > 1) overlap++; }); return overlap; } function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\$\\$/g, '\\$&'); } /* highlight answer safely: escape first, then wrap */ function highlightAnswer(answer, query){ let out = escapeHtml(answer || ''); // entities: capitalized chunks - wrap them (after escaping) out = out.replace(/\b([A-Z][a-z]{2,}(?:\s+[A-Z][a-z]{2,})*)\b/g, (m)=>`<span class="entity">${m}</span>`); // highlight query words (case-insensitive) const qtok = (query||'').split(/\s+/).filter(Boolean).map(q => escapeRegExp(q)); qtok.forEach(q => { const re = new RegExp(`(${q})`, 'ig'); out = out.replace(re, `<span class="highlight">$1</span>`); }); return out; } /* code extraction from HTML */ function extractCodeFromHTML(html){ try { const doc = new DOMParser().parseFromString(html, 'text/html'); const blocks = []; doc.querySelectorAll('pre, code').forEach(e=>{ const t = (e.innerText || e.textContent || '').trim(); if (t && t.length > 20) blocks.push(t); }); // dedupe const seen = new Set(); return blocks.filter(b => { const key = b.slice(0,200); if (seen.has(key)) return false; seen.add(key); return true; }).slice(0,8); } catch (e) { return []; } } /* Run JS sandbox safely inside iframe (restricted) */ function runJSInSandbox(code){ const iframe = document.createElement('iframe'); iframe.sandbox = 'allow-scripts'; iframe.style.width='100%'; iframe.style.height='180px'; iframe.style.border='1px solid rgba(255,255,255,0.06)'; iframe.style.marginTop='8px'; codeviewEl.appendChild(iframe); const doc = iframe.contentWindow.document; doc.open(); // wrap in try/catch, avoid exposing parent doc.write(`<body style="background:#00111a;color:#cfeff8;font-family:monospace;padding:8px;white-space:pre-wrap"></body><script> try { (function(){ ${code} })(); } catch(e) { document.body.innerText = 'Runtime error: ' + (e && e.message ? e.message : e); } <\/script>`); doc.close(); } /* translate by scraping mobile translate - best-effort */ async function translateTextViaProxy(text, target='en'){ if (!text) return null; const base = 'https://translate.google.com/m'; const url = `${base}?hl=en&sl=auto&tl=${encodeURIComponent(target)}&q=${encodeURIComponent(text)}`; try { const fetched = await tryFetch(url, proxyModeEl.value); const html = fetched.html || ''; const doc = new DOMParser().parseFromString(html,'text/html'); // look for result container element(s) const resEl = doc.querySelector('.result-container') || doc.querySelector('.t0') || doc.querySelector('.gt-baf-table') || doc.querySelector('div'); if (resEl) { const t = (resEl.innerText || resEl.textContent || '').trim(); if (t && t !== text) return t; } // fallback: search for short text different from input const paragraphs = Array.from(doc.querySelectorAll('p,div')).map(n => (n.innerText||n.textContent||'').trim()).filter(Boolean); for (const p of paragraphs) { if (p.length > 1 && p.length < 400 && p.toLowerCase() !== text.toLowerCase()) return p; } return null; } catch (e) { console.warn('translate failed', e && e.message); return null; } } /* OCR handler using Tesseract.js */ document.getElementById('imgfile').addEventListener('change', async (ev) => { const f = ev.target.files[0]; if (!f) return; answerEl.textContent = 'OCR running — please wait...'; statusEl.textContent = 'Running Tesseract OCR...'; try { const worker = Tesseract.createWorker({ logger: m => console.log('tesseract', m) }); await worker.load(); await worker.loadLanguage('eng'); await worker.initialize('eng'); const { data: { text } } = await worker.recognize(f); await worker.terminate(); if (!text || text.trim().length < 10) { answerEl.textContent = 'OCR succeeded but returned little text.'; statusEl.textContent = 'OCR done.'; return; } // Summarize the OCR text const paras = text.split(/\n+/).map(p => p.trim()).filter(Boolean); const fakeSnips = paras.slice(0, 8); const res = synthesizeAnswer(fakeSnips, [], paras.join(' ')); answerEl.innerHTML = highlightAnswer(res.answer, ''); confEl.textContent = res.conf || 'Medium'; statusEl.textContent = 'OCR + summary complete.'; } catch (err) { console.error('OCR error', err); answerEl.textContent = 'OCR error: ' + (err.message || err); statusEl.textContent = 'OCR failed.'; } finally { ev.target.value = ''; } }); /* UI toggles */ toggleSourcesBtn.onclick = () => { if (sourcesEl.style.display === 'block') { sourcesEl.style.display = 'none'; toggleSourcesBtn.textContent = 'Sources'; } else { sourcesEl.style.display = 'block'; toggleSourcesBtn.textContent = 'Hide sources'; } }; toggleSnipsBtn.onclick = () => { if (snippetsEl.style.display === 'block') { snippetsEl.style.display = 'none'; toggleSnipsBtn.textContent = 'Raw snippets'; } else { snippetsEl.style.display = 'block'; toggleSnipsBtn.textContent = 'Hide snippets'; } }; toggleCodeBtn.onclick = () => { if (codeviewEl.style.display === 'block') { codeviewEl.style.display = 'none'; toggleCodeBtn.textContent = 'Code view'; } else { codeviewEl.style.display = 'block'; toggleCodeBtn.textContent = 'Hide code'; } }; /* download answer JSON */ downloadBtn.onclick = () => { const data = { query: qInput.value, answer: answerEl.innerText, confidence: confEl.innerText, time: new Date().toISOString() }; const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'beast_answer.json'; a.click(); setTimeout(() => URL.revokeObjectURL(a.href), 60000); }; /* Main search flow */ goBtn.addEventListener('click', async () => { const q = (qInput.value || '').trim(); if (!q) { answerEl.textContent = 'Type a question first.'; return; } try { await runQueryFlow(q); } catch (err) { console.error('runQueryFlow error', err); answerEl.textContent = 'Error: ' + (err.message || err); statusEl.textContent = 'Failed.'; } }); qInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') goBtn.click(); }); /* Primary orchestration */ async function runQueryFlow(rawQuery) { const query = (rawQuery || '').trim(); answerEl.textContent = 'Searching & synthesizing…'; statusEl.textContent = 'Normalizing query & selecting proxy...'; correctionEl.textContent = ''; confEl.textContent = '—'; sourcesEl.style.display = 'none'; snippetsEl.style.display = 'none'; codeviewEl.style.display = 'none'; provEl.style.display = 'none'; sourcesEl.innerHTML = ''; snippetsEl.innerHTML = ''; codeviewEl.innerHTML = ''; provEl.innerHTML = ''; const engine = engineEl.value; const proxyMode = proxyModeEl.value; const qenc = encodeURIComponent(query); const targetUrl = engine === 'duckduckgo' ? `https://duckduckgo.com/html/?q=${qenc}` : `https://www.bing.com/search?q=${qenc}&ensearch=1`; let fetchResult; try { fetchResult = await tryFetch(targetUrl, proxyMode); } catch (err) { // fallback: try Wikipedia console.warn('primary fetch failed, try wiki fallback', err); statusEl.textContent = 'Primary fetch failed; trying Wikipedia fallback...'; try { const wikiUrl = `https://en.wikipedia.org/w/index.php?search=${qenc}`; fetchResult = await tryFetch(wikiUrl, proxyMode); } catch (err2) { console.error('wikipedia fallback failed', err2); throw new Error('Network/proxy fetch failed. Try switching proxy mode or run a local fetcher.'); } } const html = (fetchResult && fetchResult.html) ? fetchResult.html : ''; const usedProxy = (fetchResult && fetchResult.usedProxy) ? fetchResult.usedProxy : 'unknown'; statusEl.textContent = `Parsing results (proxy: ${usedProxy})...`; const extracted = extractSnippetsAndLinksFromHTML(html, engine, targetUrl); let snippets = extracted.snippets || []; let links = extracted.links || []; const pageCodes = extracted.codes || []; // If no snippets, attempt direct page first link pages if ((!snippets || snippets.length === 0) && links && links.length > 0) { // try to fetch first link to get context try { const r2 = await tryFetch(links[0].href, proxyMode); const ex2 = extractSnippetsAndLinksFromHTML(r2.html || '', 'generic', links[0].href); snippets = snippets.concat(ex2.snippets); links = links.concat(ex2.links); } catch (e) { console.warn('fetch of top link failed', e); } } // perform simple auto-correction only if we have context words const contextWords = snippets.flatMap(s => (s||'').split(/\W+/).filter(Boolean)).slice(0, 800); const tokens = query.split(/\s+/).filter(Boolean); const correctedTokens = []; const corrections = []; for (const t of tokens) { const corr = bestCorrection(t, contextWords); if (corr && corr.toLowerCase() !== t.toLowerCase()) { corrections.push({ from: t, to: corr }); correctedTokens.push(corr); } else correctedTokens.push(t); } const correctedQuery = correctedTokens.join(' '); if (corrections.length > 0) { correctionEl.innerHTML = `Auto-corrected: <b>${escapeHtml(correctedQuery)}</b>`; } // Re-query if correction was made and there were few snippets if (corrections.length > 0 && snippets.length < 3) { statusEl.textContent = 'Re-querying for corrected query...'; try { const r3 = await tryFetch(engine === 'duckduckgo' ? `https://duckduckgo.com/html/?q=${encodeURIComponent(correctedQuery)}` : `https://www.bing.com/search?q=${encodeURIComponent(correctedQuery)}&ensearch=1`, proxyMode); const ex3 = extractSnippetsAndLinksFromHTML(r3.html || '', engine, r3.usedProxy || ''); if (ex3 && ex3.snippets && ex3.snippets.length > snippets.length) { snippets = ex3.snippets; links = ex3.links; } } catch (e) { console.warn('requery failed', e); } } // Summarize statusEl.textContent = 'Synthesizing concise answer...'; const synth = synthesizeAnswer(snippets, links, correctedQuery || query); confEl.textContent = synth.conf || 'Medium'; answerEl.innerHTML = highlightAnswer(synth.answer, correctedQuery || query); // Populate sources (top 3) sourcesEl.innerHTML = ''; if (links && links.length > 0) { for (let i=0;i<Math.min(4, links.length); i++){ const l = links[i]; const div = document.createElement('div'); div.className = 'source-item'; const snipPreview = snippets[i] || ''; div.innerHTML = `<div style="font-size:13px"><a href="${escapeHtml(l.href)}" target="_blank" rel="noopener noreferrer">${escapeHtml(l.text || l.href)}</a></div> <div class="small" style="margin-top:6px">${escapeHtml(snipPreview)}</div>`; sourcesEl.appendChild(div); } } else { sourcesEl.innerHTML = '<div class="small">No source links found.</div>'; } // Raw snippets snippetsEl.innerHTML = ''; if (snippets && snippets.length) { snippets.forEach(s => { const d = document.createElement('div'); d.className='snippet'; d.innerText = s; snippetsEl.appendChild(d); }); } else { snippetsEl.innerHTML = '<div class="small">No snippets available.</div>'; } // Code extraction if query looks like code request or page contained code const codeBlocks = []; codeBlocks.push(...pageCodes); if (/\b(code|javascript|python|java|c\+\+|cpp|ruby|php|sql|bash|shell|function|class|implement)\b/i.test(query)) { // attempt to fetch top link(s) code snippets for (const l of (links || []).slice(0,3)) { try { const r = await tryFetch(l.href, proxyMode); const cb = extractCodeFromHTML(r.html || ''); codeBlocks.push(...cb); } catch (e) { console.warn('code fetch failed for', l.href, e && e.message); } } } if (codeBlocks.length > 0) { codeviewEl.innerHTML = ''; codeviewEl.style.display = 'block'; codeBlocks.slice(0,6).forEach(cb => { const pre = document.createElement('pre'); pre.className='code-block'; pre.textContent = cb; codeviewEl.appendChild(pre); // show run button only for plausible JS snippets if (/javascript|node|console\.log|function|=>|document\./i.test(cb)) { const runBtn = document.createElement('button'); runBtn.className='runjs'; runBtn.textContent='Run (JS)'; runBtn.onclick = ()=> runJSInSandbox(cb); codeviewEl.appendChild(runBtn); } }); } else { codeviewEl.style.display = 'none'; } // Provenance provEl.innerHTML = '<b>Provenance</b>'; if (synth.usedSentences && synth.usedSentences.length) { synth.usedSentences.forEach(s => { const d = document.createElement('div'); d.className = 'snippet'; d.innerText = s; provEl.appendChild(d); }); provEl.style.display = 'block'; } else provEl.style.display = 'none'; statusEl.textContent = 'Done.'; } /* translate button */ translateBtn.onclick = async () => { const text = window.getSelection().toString() || answerEl.innerText || qInput.value; if (!text) return alert('Select or show some text to translate.'); const tgt = prompt('Target language code (en, hi, es...). Default en','en') || 'en'; statusEl.textContent = 'Translating...'; const tr = await translateTextViaProxy(text, tgt); if (tr) { answerEl.innerHTML = `<div style="opacity:0.9"><b>Translated (${tgt}):</b></div><div style="margin-top:8px">${escapeHtml(tr)}</div><hr style="opacity:0.06;margin:10px 0"/><div class="small">Original:</div><div style="margin-top:6px">${escapeHtml(text)}</div>`; statusEl.textContent = 'Translation done.'; } else { statusEl.textContent = 'Translation failed (proxy/site layout might block scraping).'; alert('Translation not available.'); } }; /* small helper: escapeRegExp already defined above */ function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\$\\$/g, '\\$&'); } </script> </body> </html>
